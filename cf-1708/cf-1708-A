// Problem
You are given an array ğ‘ consisting of ğ‘› positive integers.

You are allowed to perform this operation any number of times (possibly, zero):

    choose an index ğ‘– (2â‰¤ğ‘–â‰¤ğ‘›), and change ğ‘ğ‘– to ğ‘ğ‘–âˆ’ğ‘ğ‘–âˆ’1. 

Is it possible to make ğ‘ğ‘–=0 for all 2â‰¤ğ‘–â‰¤n?

// Input

The input consists of multiple test cases. The first line contains a single integer ğ‘¡ (1â‰¤ğ‘¡â‰¤100)  â€” the number of test cases. The description of the test cases follows.

The first line contains one integer n(2â‰¤ğ‘›â‰¤100)Â â€” the length of array ğ‘.

The second line contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤10^9).

// Output

For each test case, print "YES" (without quotes), if it is possible to change ğ‘ğ‘– to 0 for all 2â‰¤ğ‘–â‰¤ğ‘› , and "NO" (without quotes) otherwise.

You can print letters in any case (upper or lower).

// Example
// Input
4
2
5 10
3
1 2 3
4
1 1 1 1
9
9 9 8 2 4 4 3 5 3

// Output
YES
YES
YES
NO


//  Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  
  while (t--) {
    int n;
    cin >> n;
    
    bool res = true;
    
    int val1;
    cin >> val1;
    n--;
    
    while(n--) {
      int val;
      cin >> val;
      
      res = res && (val % val1 == 0);  
    }
    
    cout << (res ? "YES" : "NO") << endl;
    
  }
  return 0;
}
