// Problem
An array ğ‘ is good if the sum of elements of ğ‘ is even.

You are given an array ğ‘ consisting of ğ‘› positive integers. In one operation, you can select an index ğ‘– and change ğ‘ğ‘–:=âŒŠğ‘ğ‘–2âŒ‹. â€ Find the minimum number of operations (possibly 0) needed to make ğ‘ good. It can be proven that it is always possible to make ğ‘ good.

â€ âŒŠğ‘¥âŒ‹ denotes the floor function â€” the largest integer less than or equal to ğ‘¥. For example, âŒŠ2.7âŒ‹=2, âŒŠğœ‹âŒ‹=3 and âŒŠ5âŒ‹=5.

// Input

Each test contains multiple test cases. The first line contains a single integer ğ‘¡(1â‰¤ğ‘¡â‰¤1000) â€” the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer ğ‘› (1â‰¤ğ‘›â‰¤50) â€” the length of the array ğ‘.

The second line of each test case contains ğ‘› space-separated integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤10^6) â€” representing the array ğ‘.

Do note that the sum of ğ‘› over all test cases is not bounded.

// Output

For each test case, output the minimum number of operations needed to make ğ‘ good.

// Example
// Input
4
4
1 1 1 1
2
7 4
3
1 2 4
1
15

// Output
0
2
1
4

// Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    int sum = 0;
    vector<int> vec(n);
    for (int i = 0; i < n; ++i) {
      cin >> vec[i];
      sum += vec[i];
    }

    int res = 10000000;    
    if (sum % 2 == 0) {
      res = 0;
    } else {
      for (int i = 0; i < n; ++i) {
        int val = vec[i];
        if (val % 2 == 0) {
          int tmp = 0;
          while (val%2 == 0) {
            val = val/2;
            tmp++;
          }
          res = min(res, tmp);
        } else {
          int tmp = 0;
          while (val%2 != 0) {
            val = val/2;
            tmp++;
          }
          res = min(res, tmp);          
        }
      }
    }
    
    cout << res << endl;
  }
  return 0;
}
