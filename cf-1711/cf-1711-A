// Problem
You are given a positive integer ğ‘›.

The weight of a permutation ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› is the number of indices 1â‰¤ğ‘–â‰¤ğ‘› such that ğ‘– divides ğ‘ğ‘–. Find a permutation ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› with the minimum possible weight (among all permutations of length ğ‘›).

A permutation is an array consisting of ğ‘› distinct integers from 1 to ğ‘› in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (ğ‘›=3 but there is 4 in the array).

// Input

Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1â‰¤ğ‘¡â‰¤10^4). The description of the test cases follows.

The only line of each test case contains a single integer ğ‘› (1â‰¤ğ‘›â‰¤10^5) â€” the length of permutation.

It is guaranteed that the sum of ğ‘› over all test cases does not exceed 10^5.

// Output

For each test case, print a line containing ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› so that the permutation ğ‘ has the minimum possible weight.

If there are several possible answers, you can print any of them.

// Example
// Input
2
1
4

// Output
1
2 1 4 3

// Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  
  while (t--) {
    int n;
    cin >> n;
    
    for (int i = 2; i <= n; ++i) {
      cout << i << " ";
    }
    cout << 1 << endl;
  }
  
  return 0;
}
