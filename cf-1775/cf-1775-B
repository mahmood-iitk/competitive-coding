// Problem
The gardener Kazimir Kazimirovich has an array of ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›.

He wants to check if there are two different subsequences ğ‘ and ğ‘ of the original array, for which ğ‘“(ğ‘)=ğ‘“(ğ‘), where ğ‘“(ğ‘¥) is the bitwise OR of all of the numbers in the sequence ğ‘¥.

A sequence ğ‘ is a subsequence of ğ‘ if ğ‘ can be obtained from ğ‘ by deleting several (possibly none or all) elements.

Two subsequences are considered different if the sets of indexes of their elements in the original sequence are different, that is, the values of the elements are not considered when comparing the subsequences.

// Input

Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1â‰¤ğ‘¡â‰¤10^5). The description of the test cases follows.

The first line of each test case contains one integer ğ‘› (1â‰¤ğ‘›â‰¤10^5)Â â€” the size of the array ğ‘.

The description of the array ğ‘ in this problem is given implicitly to speed up input.

The (ğ‘–+1)-st of the following ğ‘› lines of the test case begins with an integer ğ‘˜ğ‘– (1â‰¤ğ‘˜ğ‘–â‰¤10^5)Â â€” the number of set bits in the number ğ‘ğ‘–. Next follow ğ‘˜ğ‘– distinct integers ğ‘ğ‘–,1,ğ‘ğ‘–,2,â€¦,ğ‘ğ‘–,ğ‘˜ğ‘– (1â‰¤ğ‘ğ‘–â‰¤2â‹…10^5)Â â€”the numbers of bits that are set to one in number ğ‘ğ‘–. In other words, ğ‘ğ‘–=2^(ğ‘ğ‘–,1) + 2^(ğ‘ğ‘–,2) + â€¦ + 2^(ğ‘ğ‘–,ğ‘˜ğ‘–).

It is guaranteed that the total sum of ğ‘˜ğ‘– in all tests does not exceed 10^5.

// Output

For each set of input, print "Yes" if there exist two different subsequences for which ğ‘“(ğ‘)=ğ‘“(ğ‘), and "No" otherwise.

You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.

// Example
// Input
5
3
2 1 5
2 2 4
2 2 3
2
2 1 2
1 2
4
3 1 2 4
2 2 4
4 1 2 5 6
2 2 5
5
3 3 1 2
3 2 5 3
5 7 2 3 1 4
5 1 2 6 3 5
3 2 6 3
2
1 1
1 2

// Output
No
Yes
Yes
Yes
No

// Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    bool res = false;
    
    vector<vector<int>> vec;
    for (int i = 0; i < n; ++i) {
      int k;
      cin >> k;
      vector<int> int_vec(k);
      for (int j = 0; j < k; j++) {
        cin >> int_vec[j];
      }
      vec.push_back(int_vec);
    }
    
    map<int, int> bit_to_count;
    for (int i = 0; i < n; ++i) {
      for (const int val : vec[i]) {
        bit_to_count[val]++;
      }
    }
    
    for (int i = 0; i < n; ++i) {
      bool all_bits_already_set = true;
      for (const int val : vec[i]) {
        if (bit_to_count[val] == 1) {
          all_bits_already_set = false;
        }
      }
      if (all_bits_already_set) {
        res = true;
      }
    }
    
    if (res) {
      cout << "YES";
    } else {
      cout << "no";
    }
    cout << endl;
  }
  
  return 0;
}
