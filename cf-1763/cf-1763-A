// Problem
You are given an array ğ‘ of length ğ‘›. You can perform the following operation several (possibly, zero) times:

    Choose ğ‘–, ğ‘—, ğ‘: Swap the ğ‘-th digit in the binary representation of ğ‘ğ‘– and ğ‘ğ‘—. 

Find the maximum possible value of max(ğ‘)âˆ’min(ğ‘).

In a binary representation, bits are numbered from right (least significant) to left (most significant). Consider that there are an infinite number of leading zero bits at the beginning of any binary representation.

For example, swap the 0-th bit for 4=1002 and 3=112 will result 1012=5 and 102=2. Swap the 2-nd bit for 4=1002 and 3=112 will result 0002=02=0 and 1112=7.

Here, max(ğ‘)denotes the maximum element of array ğ‘ and min(ğ‘) denotes the minimum element of array ğ‘.

The binary representation of ğ‘¥ is ğ‘¥ written in base 2. For example, 9 and 6 written in base 2 are 1001 and 110, respectively.

// Input

The first line contains a single integer ğ‘¡(1â‰¤ğ‘¡â‰¤128) â€” the number of testcases.

The first line of each test case contains a single integer ğ‘›(3â‰¤ğ‘›â‰¤512) â€” the length of array ğ‘.

The second line of each test case contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (0â‰¤ğ‘ğ‘–<1024) â€” the elements of array ğ‘.

It's guaranteed that the sum of ğ‘› over all testcases does not exceed 512.

// Output

For each testcase, print one integer â€” the maximum possible value of max(ğ‘)âˆ’min(ğ‘).

// Example
// Input
4
3
1 0 1
4
5 5 5 5
5
1 2 3 4 5
7
20 85 100 41 76 49 36

// Output
1
0
7
125


// Solution
#include <bits/stdc++.h>

using namespaec std;

int main() {
  int t;
  cin >> t;
  
  while (t--) {
    int n;
    cin >> n;
    
    int max = -1;
    int min = -1;
    
    for (int i = 0 ; i < n; ++i) {
      int val;
      cin >> val;
      if (max == -1) {
        max = val;
        min = val;
        continue;
      }
      
      max = max | val;
      min = min & val;
    }
    cout << max - min << endl;
  }
  return 0;
}
