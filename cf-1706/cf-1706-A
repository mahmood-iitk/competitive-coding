// Problem
You have a sequence ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› of length ğ‘›, consisting of integers between 1 and ğ‘š. You also have a string ğ‘ , consisting of ğ‘š characters B.

You are going to perform the following ğ‘›operations.

    At the ğ‘–-th (1â‰¤ğ‘–â‰¤ğ‘›) operation, you replace either the ğ‘ğ‘–-th or the (ğ‘š+1âˆ’ğ‘ğ‘–)-th character of ğ‘ 
    with A. You can replace the character at any position multiple times through the operations. 

Find the lexicographically smallest string you can get after these operations.

A string ğ‘¥ is lexicographically smaller than a string ğ‘¦ of the same length if and only if in the first position where ğ‘¥ and ğ‘¦ differ, the string ğ‘¥ has a letter that appears earlier in the alphabet than the corresponding letter in ğ‘¦.

// Input

The first line contains the number of test cases ğ‘¡(1â‰¤ğ‘¡â‰¤2000).

The first line of each test case contains two integers ğ‘› and ğ‘š (1â‰¤ğ‘›,ğ‘šâ‰¤50)Â â€” the length of the sequence ğ‘ and the length of the string ğ‘  respectively.

The second line contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤ğ‘š)Â â€” the sequence ğ‘.

// Output

For each test case, print a string of length ğ‘šÂ â€” the lexicographically smallest string you can get. Each character of the string should be either capital English letter A or capital English letter B.

// Example
// Input
6
4 5
1 1 3 1
1 5
2
4 1
1 1 1 1
2 4
1 3
2 7
7 5
4 5
5 5 3 5

// Output
ABABA
BABBB
A
AABB
ABABBBB
ABABA

// Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n, m;
    cin >> n >> m;
    
    vector<int> vec(n);
    for (int i = 0; i < n; ++i) {
      cin >> vec[i];
    }
    
    set<int> my_set;
    for (int i = 0; i < n; ++i) {
      if (my_set.find(vec[i]) != my_set.end()) {
        my_set.emplace(m + 1 - vec[i]);  
        continue;
      }
      
      if (my_set.find(m + 1 - vec[i]) != my_set.end()) {
        my_set.emplace(vec[i]);  
        continue;
      }
      
      if (vec[i] < (m + 1 - vec[i])) {
        my_set.emplace(vec[i]);
      } else {
        my_set.emplace(m + 1 - vec[i]);
      }
    }
    
    for (int i = 1; i <= m; ++i) {
      if (my_set.find(i) == my_set.end()) {
        cout << "B";
      } else {
        cout << "A";
      }
    }
    cout << endl;
    
  }
}
