// Problem
You are given a permutation ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› of length ğ‘› and a positive integer ğ‘˜â‰¤ğ‘›.

In one operation you can choose two indices ğ‘– and ğ‘— (1â‰¤ğ‘–<ğ‘—â‰¤ğ‘›) and swap ğ‘ğ‘– with ğ‘ğ‘—.

Find the minimum number of operations needed to make the sum ğ‘1+ğ‘2+â€¦+ğ‘ğ‘˜ as small as possible.

A permutation is an array consisting of ğ‘› distinct integers from 1 to ğ‘› in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (ğ‘›=3 but there is 4 in the array).

// Input
Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡(1â‰¤ğ‘¡â‰¤100). Description of the test cases follows.

The first line of each test case contains two integers ğ‘› and ğ‘˜ (1â‰¤ğ‘˜â‰¤ğ‘›â‰¤100).

The second line of each test case contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤ğ‘›). It is guaranteed that the given numbers form a permutation of length ğ‘›.

// Output

For each test case print one integerÂ â€” the minimum number of operations needed to make the sum ğ‘1+ğ‘2+â€¦+ğ‘ğ‘˜ as small as possible.

// Example
// Input
4
3 1
2 3 1
3 3
1 2 3
4 2
3 4 1 2
1 1
1

// Output
1
0
2
0

// Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n, k;
    cin >> n >> k;
    
    int res  = 0;
    for (int i = 0; i < n; ++i) {
      int val;
      cin >> val;
      if (i >= k) {
        continue;
      }
      if (val > k) {
        res++;
      }
    }
    
    cout << res << endl;
  }
}
