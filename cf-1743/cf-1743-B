// Problem
You are given an integer ğ‘›. You have to construct a permutation of size ğ‘›.

A permutation is an array where each integer from 1 to ğ‘  (where ğ‘  is the size of permutation) occurs exactly once. For example, [2,1,4,3] is a permutation of size 4; [1,2,4,5,3] is a permutation of size 5; [1,4,3] is not a permutation (the integer 2 is absent), [2,1,3,1] is not a permutation (the integer 1 appears twice).

A subsegment of a permutation is a contiguous subsequence of that permutation. For example, the permutation [2,1,4,3] has 10 subsegments: [2], [2,1], [2,1,4], [2,1,4,3], [1], [1,4], [1,4,3], [4], [4,3] and [3].

The value of the permutation is the number of its subsegments which are also permutations. For example, the value of [2,1,4,3] is 3 since the subsegments [2,1], [1] and [2,1,4,3] are permutations.

You have to construct a permutation of size ğ‘› with minimum possible value among all permutations of size ğ‘›.

// Input

The first line contains one integer ğ‘¡ (1 â‰¤ ğ‘¡ â‰¤ 48) â€” the number of test cases.

Then, ğ‘¡ lines follow. The ğ‘–-th of them contains one integer ğ‘› (3 â‰¤ ğ‘› â‰¤ 50) representing the ğ‘–-th test case.

// Output

For each test case, print ğ‘› integers â€” the permutation of size ğ‘› with minimum possible value. If there are multiple such permutations, print any of them.

// Example
// Input
2
5
6

// Output
1 4 3 5 2
4 1 6 2 5 3

// Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;
    
    if (n == 1) {
      cout << "1" << endl;
      continue;
    }
    
    cout << 1 << " " << n << " ";
    for (int i = 2; i < n; ++i) {
      cout << i << " ";
    }
    cout << endl;
  }
}
