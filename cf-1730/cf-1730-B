// Problem
ğ‘› people live on the coordinate line, the ğ‘–-th one lives at the point ğ‘¥ğ‘– (1â‰¤ğ‘–â‰¤ğ‘›). They want to choose a position ğ‘¥0 to meet. The ğ‘–-th person will spend |ğ‘¥ğ‘–âˆ’ğ‘¥0| minutes to get to the meeting place. Also, the ğ‘–-th person needs ğ‘¡ğ‘– minutes to get dressed, so in total he or she needs ğ‘¡ğ‘–+|ğ‘¥ğ‘–âˆ’ğ‘¥0| minutes.

Here |ğ‘¦| denotes the absolute value of ğ‘¦.

These people ask you to find a position ğ‘¥0 that minimizes the time in which all ğ‘›

people can gather at the meeting place.
// Input

The first line contains a single integer ğ‘¡ (1â‰¤ğ‘¡â‰¤10^3) â€” the number of test cases. Then the test cases follow.

Each test case consists of three lines.

The first line contains a single integer ğ‘› (1â‰¤ğ‘›â‰¤10^5)Â â€” the number of people.

The second line contains ğ‘› integers ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘› (0â‰¤ğ‘¥ğ‘–â‰¤10^8) â€” the positions of the people.

The third line contains ğ‘› integers ğ‘¡1,ğ‘¡2,â€¦,ğ‘¡ğ‘› (0â‰¤ğ‘¡ğ‘–â‰¤10^8), where ğ‘¡ğ‘– is the time ğ‘–-th person needs to get dressed.

It is guaranteed that the sum of ğ‘› over all test cases does not exceed 2â‹…10^5.
// Output

For each test case, print a single real numberÂ â€” the optimum position ğ‘¥0. It can be shown that the optimal position ğ‘¥0 is unique.

Your answer will be considered correct if its absolute or relative error does not exceed 10^âˆ’6. Formally, let your answer be ğ‘, the jury's answer be ğ‘. Your answer will be considered correct if (|ğ‘âˆ’ğ‘|)/ğ‘šğ‘ğ‘¥(1,|ğ‘|) â‰¤ (10^âˆ’6).

// Example
// Input
7
1
0
3
2
3 1
0 0
2
1 4
0 0
3
1 2 3
0 0 0
3
1 2 3
4 1 2
3
3 3 3
5 3 3
6
5 4 7 2 10 4
3 2 5 1 4 6

// Output
0
2
2.5
2
1
3
6


// Solution
#include <bits/stdc++.h>

using namespace std;

int main() {
  int t;
  cin >> t;
  while(t--) {
    int n;
    cin >> n;
    vector<pair<int, int>> pos_time(n);
    
    for (int i = 0; i < n; ++i) {
      cin >> pos_time[i].first;
    }
    
    for (int i = 0; i < n; ++i) {
      cin >> pos_time[i].second;
    }
    
    sort(pos_time.begin(), pos_time.end());
    
    // if (n == 1) {
    //   cout << pos_time[0].first << endl;
    //   continue;
    // }
    
    double time_spent = pos_time[0].second;
    double position = pos_time[0].first;
    for (int i = 1; i < n; ++i) {
      double at_least_time_needed = pos_time[i].second - time_spent;
      if (at_least_time_needed > 0.0) {     
        time_spent += at_least_time_needed;
        position += at_least_time_needed;
        position = min(position, (double)pos_time[i].first);
      }
      
      double ith_position = pos_time[i].first + pos_time[i].second - time_spent;
      ith_position = max(ith_position, position);
      double time_needed = (ith_position - position) / 2.0;
      time_spent += time_needed;
      position += time_needed;
    }
    
    cout << fixed << setprecision(6) << position << endl;
  }
}
